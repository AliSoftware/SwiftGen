// Generated using SwiftGen, by O.Halligon â€” https://github.com/AliSoftware/SwiftGen

public final class {{ spec.type }}: DataModel, Equatable {
{% for field in spec.fields %}
    public let {{ field.name }}: {{field|paramType}}
{% endfor %}

    public init({{ spec.fields|paramList|join }}) {
{% for field in spec.fields %}
        self.{{ field.name }} = {{ field.name }}
{% endfor %}
    }

    public init(dictionary: [String: Any]) throws {
        let parser = Parser(dictionary: dictionary)
{% for field in spec.fields %}
        self.{{ field.name }} = try parser.fetch("{{ field.name }}")
{% endfor %}
    }

    public static func parsed(data: Any) throws -> UnitTestClass {
        if let data = data as? [String: Any] {
            return try {{ spec.type }}(dictionary: data)
        }
        throw ParserError(message: "Expected a [String: Any] but got \(type(of: data))")
    }

    public func data() -> [String: Any] {
        var data = [String: Any]()
{% for field in spec.fields %}
        data["{{ field.name }}"] = {{ field.name }}{% if field.optional %}?{% endif %}{% ifstrequal "array" field.type %}.map { $0.dataRepresentation() }{% else %}.dataRepresentation(){% endif %}
{% endfor %}
        return data
    }

    public func map(update: (Builder)->()) -> {{ spec.type }} {
        let builder = Builder(copy: self)
        update(builder)
        return builder.build()
    }

    public final class Builder {
{% for field in spec.fields %}
        public var {{ field.name }}: {{field|paramType}}
{% endfor %}

        public init(copy: {{spec.type}}) {
{% for field in spec.fields %}
            {{field.name}} = copy.{{field.name}}
{% endfor %}
        }

        public func build() -> {{spec.type}} {
            return {{spec.type}}({{ spec.fields|initializerList|join }})
        }
    }
}

public func ==(lhs: {{spec.type}}, rhs: {{spec.type}}) -> Bool {
    return {{ spec.fields|equalityList|join&& }}
}
